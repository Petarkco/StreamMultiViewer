<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Responsive Multi-Stream Viewer</title>

    <!-- Icons: Google Material Symbols -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:FILL@0..1&opsz=24..48,wght@100..700,GRAD@-25..200"
        rel="stylesheet">

    <!-- HLS.js and dash.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/hls.js@1.5.8/dist/hls.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/dashjs@4.7.4/dist/dash.all.min.js"></script>

    <style>
        :root {
            --bg: #0b0f14;
            --panel: #121820;
            --text: #e6eef8;
            --muted: #8fa3b8;
            --accent: #3ea6ff;
            --danger: #ff5470;
            --ok: #45d483;
            --tile-gap: 10px;
            --toolbar-h: 40px;
            --radius: 14px;
            --overlay-bg: rgba(6, 10, 14, .75);
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font: 14px system-ui, Segoe UI, Roboto, Inter, Arial
        }

        header {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 10px;
            background: var(--panel);
            position: sticky;
            top: 0;
            z-index: 5
        }

        header input[type=url] {
            flex: 1;
            min-width: 200px;
            border: 1px solid #223040;
            background: #0e141c;
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px
        }

        header .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid #26364a;
            background: #13202e;
            color: var(--text);
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer
        }

        header .btn:hover {
            border-color: #345276
        }

        header label {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--muted)
        }

        #grid {
            display: grid;
            gap: var(--tile-gap);
            height: calc(100dvh - 60px);
            padding: 10px;
            grid-auto-rows: 1fr
        }

        .tile {
            position: relative;
            background: #000;
            border-radius: var(--radius);
            overflow: hidden
        }

        .tile video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000;
            display: block
        }

        /* Controls overlay */
        .controls {
            position: absolute;
            inset: auto 0 0 0;
            height: var(--toolbar-h);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 8px;
            background: linear-gradient(to top, rgba(0, 0, 0, .55), rgba(0, 0, 0, .0));
            opacity: 0;
            pointer-events: none;
            transition: opacity .15s ease
        }

        .tile:hover .controls,
        .controls.show {
            opacity: 1;
            pointer-events: auto
        }

        .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 34px;
            height: 34px;
            border-radius: 10px;
            cursor: pointer;
            user-select: none
        }

        .icon:hover {
            background: rgba(255, 255, 255, .1)
        }

        .icon.danger:hover {
            background: rgba(255, 84, 112, .15)
        }

        .material-symbols-outlined {
            font-variation-settings: "FILL" 0, "wght" 500, "GRAD" 0, "opsz" 28;
            line-height: 1
        }

        /* Volume popover: stays open while moving from button to slider */
        .vol-wrap {
            position: relative;
            display: flex;
            align-items: center
        }

        .vol-pop {
            position: absolute;
            bottom: 44px;
            left: 0;
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            border-radius: 10px;
            background: var(--overlay-bg);
            backdrop-filter: blur(4px)
        }

        .vol-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 120px
        }

        /* Top-left badge */
        .badge {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, .6);
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            color: #cfe0f7
        }

        /* Error layer */
        .error {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: var(--overlay-bg);
            color: #fff;
            text-align: center
        }

        .error.show {
            display: flex
        }

        .error .panel {
            max-width: 520px;
            background: #111926;
            border: 1px solid #2b3e56;
            border-radius: 12px;
            padding: 14px
        }

        .error .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px
        }

        .error .btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #26364a;
            background: #13202e;
            color: #fff;
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer
        }

        /* Menus */
        .menu {
            position: absolute;
            bottom: 48px;
            right: 8px;
            background: var(--overlay-bg);
            backdrop-filter: blur(4px);
            border-radius: 12px;
            border: 1px solid #2b3e56;
            display: none;
            min-width: 240px;
            z-index: 2
        }

        .menu ul {
            list-style: none;
            margin: 0;
            padding: 8px
        }

        .menu li {
            padding: 8px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            cursor: pointer;
            white-space: nowrap
        }

        .menu li:hover {
            background: rgba(255, 255, 255, .08)
        }

        .menu .sep {
            margin: 6px 0;
            border-top: 1px dashed #2b3e56
        }

        .menu .hint {
            opacity: .8;
            font-size: 12px;
            padding: 6px 8px
        }

        .tile .menu.open {
            display: block
        }

        .check {
            font-size: 18px
        }

        /* Subtitle styling (built-in and Cloud CC) */
        video::cue {
            background: rgba(0, 0, 0, .65);
            color: #fff;
            border-radius: 6px;
            padding: .2em .4em
        }

        .speaker-1::cue {
            color: #aadfff
        }

        .speaker-2::cue {
            color: #ffd4a3
        }

        .speaker-3::cue {
            color: #c6ffa7
        }

        .hidden {
            display: none !important
        }

        a.clean {
            color: inherit;
            text-decoration: none
        }

        /* Hide native controls even in fullscreen (best-effort) */
        video::-webkit-media-controls {
            display: none !important
        }
    </style>
</head>

<body>
    <header>
        <input id="url" type="url" placeholder="Paste .m3u8 or .mpd URL and press Add" />
        <button class="btn" id="addBtn"><span class="material-symbols-outlined">add</span> Add</button>
        <label title="Auto-retry failed streams until they return">
            <input type="checkbox" id="autoRetry" /> Auto-retry
        </label>
    </header>

    <section id="grid" aria-live="polite" aria-label="Streams grid"></section>

    <script>
        (function () {
            const grid = document.getElementById('grid');
            const addBtn = document.getElementById('addBtn');
            const urlInput = document.getElementById('url');
            const autoRetry = document.getElementById('autoRetry');

            // --- Cookie persistence (rolling 1 year) ---
            function readCookie(name) {
                return document.cookie.split('; ').find(row => row.startsWith(name + '='))?.split('=')[1] ?? '';
            }
            function saveStreams(urls) {
                const value = encodeURIComponent(JSON.stringify(urls));
                document.cookie = 'streams=' + value + '; Max-Age=' + (60 * 60 * 24 * 365) + '; Path=/; SameSite=Lax';
            }
            function loadStreams() {
                try { return JSON.parse(decodeURIComponent(readCookie('streams') || '[]')) || [] } catch { return [] }
            }

            // --- Layout: compute rows/cols that maximize tile area and fit all streams ---
            function layout() {
                const n = grid.children.length; if (!n) return;
                const vw = window.innerWidth - 20;
                const vh = (window.innerHeight - document.querySelector('header').offsetHeight) - 20;
                let best = { rows: 1, cols: n, area: 0 };
                for (let rows = 1; rows <= n; rows++) {
                    const cols = Math.ceil(n / rows);
                    const w = Math.floor(vw / cols), h = Math.floor(vh / rows);
                    const area = w * h;
                    if (area > best.area) { best = { rows, cols, area }; }
                }
                grid.style.gridTemplateColumns = 'repeat(' + best.cols + ', 1fr)';
            }
            window.addEventListener('resize', layout);

            // --- Players ---
            const tiles = new Map(); // id -> state
            let idSeq = 0;

            function addStream(url) {
                url = url.trim(); if (!url) return;
                const id = 't' + (++idSeq);

                const tile = document.createElement('div'); tile.className = 'tile'; tile.dataset.id = id; tile.tabIndex = 0;
                const video = document.createElement('video');
                video.playsInline = true; video.muted = true; video.autoplay = true; video.controls = false; video.disableRemotePlayback = true;
                video.setAttribute('webkit-playsinline', '');

                const badge = document.createElement('div'); badge.className = 'badge'; badge.textContent = 'Muted';

                // Controls
                const controls = document.createElement('div'); controls.className = 'controls';
                const ic = (name, title, extra = '') => {
                    const b = document.createElement('button'); b.className = 'icon ' + extra; b.title = title; b.innerHTML = '<span class="material-symbols-outlined">' + name + '</span>'; b.type = 'button'; return b;
                };

                // Single mute/unmute button (merged)
                const muteBtn = ic('volume_off', 'Mute/Unmute');

                // Volume popover
                const volWrap = document.createElement('div'); volWrap.className = 'vol-wrap';
                const volBtn = ic('volume_up', 'Volume');
                const volPop = document.createElement('div'); volPop.className = 'vol-pop';
                const volSlider = document.createElement('input'); volSlider.type = 'range'; volSlider.min = '0'; volSlider.max = '1'; volSlider.step = '0.01'; volSlider.value = '0.8'; volSlider.className = 'vol-slider';
                volPop.appendChild(volSlider); volWrap.appendChild(volBtn); volWrap.appendChild(volPop);

                // CC button now opens a CC menu (auto-translate + embedded languages + off)
                const ccBtn = ic('subtitles', 'Captions & translate');

                // Cog menu (quality)
                const cogBtn = ic('settings', 'Quality & settings');
                const openBtn = ic('open_in_new', 'Open in new tab');
                const refreshBtn = ic('refresh', 'Reload stream');
                const closeBtn = ic('close', 'Remove stream', 'danger');

                controls.append(muteBtn, volWrap, ccBtn, cogBtn, openBtn, refreshBtn, closeBtn);

                // Error overlay
                const error = document.createElement('div'); error.className = 'error';
                error.innerHTML = '<div class="panel">'
                    + '<div id="' + id + '-errmsg">Stream error. The source may be offline.</div>'
                    + '<div class="row">'
                    + '  <button class="btn" data-act="retry-now"><span class="material-symbols-outlined">refresh</span> Refresh</button>'
                    + '  <button class="btn" data-act="toggle-auto"><span class="material-symbols-outlined">autorenew</span> Auto-refresh</button>'
                    + '</div></div>';

                // Quality menu
                const qMenu = document.createElement('div'); qMenu.className = 'menu'; qMenu.innerHTML = '<ul id="' + id + '-qlist"><li>Loading levels…</li></ul>';

                // CC menu
                const ccMenu = document.createElement('div'); ccMenu.className = 'menu'; ccMenu.innerHTML = '<ul id="' + id + '-cclist"></ul>';

                tile.append(video, badge, controls, error, qMenu, ccMenu);
                grid.appendChild(tile);

                const type = url.includes('.mpd') ? 'mpd' : 'hls';
                const state = {
                    root: tile, video, url, type, hls: null, dash: null, ccOn: false,
                    retry: { on: false, timer: null, delay: 2000 }, cloudCC: null, textTrack: null,
                    ccMenu, qMenu
                };
                tiles.set(id, state);

                // Player + wiring
                setupPlayer(id, state);

                tile.addEventListener('dblclick', () => toggleFullscreen(tile));

                // Mute/unmute (single button)
                function updateMuteIcon() { muteBtn.firstElementChild.textContent = video.muted ? 'volume_off' : 'volume_up'; }
                muteBtn.addEventListener('click', () => {
                    video.muted = !video.muted;
                    badge.textContent = video.muted ? 'Muted' : 'Audio';
                    updateMuteIcon();
                });
                updateMuteIcon();

                // Volume: keep popover visible while moving to slider
                let volHoverTimer = null;
                function showVol() { clearTimeout(volHoverTimer); volPop.style.display = 'flex'; controls.classList.add('show'); }
                function hideVol() { volHoverTimer = setTimeout(() => { volPop.style.display = 'none'; controls.classList.remove('show'); }, 250); }
                volWrap.addEventListener('mouseenter', showVol);
                volWrap.addEventListener('mouseleave', hideVol);
                volPop.addEventListener('mouseenter', showVol);
                volPop.addEventListener('mouseleave', hideVol);

                volSlider.addEventListener('input', () => {
                    video.volume = parseFloat(volSlider.value);
                    if (video.muted && video.volume > 0) {
                        video.muted = false; updateMuteIcon(); badge.textContent = 'Audio';
                    }
                });

                // CC button -> open menu (rebuilt each time to reflect available tracks)
                ccBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    buildCcMenu(state);
                    ccMenu.classList.toggle('open');
                    qMenu.classList.remove('open');
                });

                // Cog menu toggle
                cogBtn.addEventListener('click', (e) => { e.stopPropagation(); qMenu.classList.toggle('open'); ccMenu.classList.remove('open'); });
                document.addEventListener('click', () => { qMenu.classList.remove('open'); ccMenu.classList.remove('open'); });

                openBtn.addEventListener('click', () => window.open(url, '_blank', 'noopener'));
                refreshBtn.addEventListener('click', () => reload(id));
                closeBtn.addEventListener('click', () => removeTile(id));

                error.querySelector('[data-act="retry-now"]').addEventListener('click', () => reload(id));
                const autoBtn = error.querySelector('[data-act="toggle-auto"]');
                autoBtn.addEventListener('click', () => {
                    state.retry.on = !state.retry.on;
                    autoBtn.classList.toggle('active', state.retry.on);
                    autoBtn.innerHTML = '<span class="material-symbols-outlined">autorenew</span> ' + (state.retry.on ? 'Stop auto-refresh' : 'Auto-refresh');
                    if (state.retry.on && !state.retry.timer) { scheduleRetry(state); }
                    if (!state.retry.on && state.retry.timer) { clearTimeout(state.retry.timer); state.retry.timer = null; state.retry.delay = 2000; }
                });

                layout(); persist();
            }

            function setupPlayer(id, state) {
                const { video, url, type } = state;

                // Cleanup
                if (state.hls) { state.hls.destroy(); state.hls = null; }
                if (state.dash) { state.dash.reset(); state.dash = null; }
                setError(state, false);

                if (type === 'hls') {
                    if (Hls.isSupported()) {
                        const hls = new Hls({ enableWorker: true, backBufferLength: 90, startLevel: -1 });
                        state.hls = hls;
                        // ensure subtitles are surfaced
                        hls.subtitleDisplay = true;

                        hls.on(Hls.Events.ERROR, (evt, data) => handleHlsError(state, data));
                        hls.on(Hls.Events.MANIFEST_PARSED, () => {
                            buildLevelsMenu(state, hls.levels?.map((l, i) => ({ i, label: levelLabel(l) })) || [], (lvl) => { hls.currentLevel = lvl; });
                            if (hls.levels && hls.levels.length) { hls.currentLevel = hls.levels.length - 1; } // default max
                            autoplay(video);
                        });
                        hls.attachMedia(video);
                        hls.loadSource(url);
                    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                        video.src = url;
                        video.addEventListener('error', () => setError(state, true, 'Native HLS error'));
                        video.addEventListener('loadedmetadata', () => {
                            buildLevelsMenu(state, [{ i: -1, label: 'Auto (native)' }], () => { });
                            autoplay(video);
                        });
                    } else {
                        setError(state, true, 'HLS not supported in this browser');
                    }
                } else {
                    const player = dashjs.MediaPlayer().create();
                    state.dash = player;
                    player.initialize(video, url, true);
                    player.updateSettings({ streaming: { abr: { autoSwitchBitrate: { video: true } } } });
                    player.on(dashjs.MediaPlayer.events.ERROR, (e) => setError(state, true, 'DASH error: ' + (e?.event?.message || '')));
                    player.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {
                        const info = player.getBitrateInfoListFor('video') || [];
                        buildLevelsMenu(state, [{ i: -1, label: 'Auto' }].concat(info.map((b, idx) => ({ i: idx, label: Math.round(b.bitrate / 1000) + ' kbps' }))).reverse(), (lvl) => {
                            if (lvl === -1) { player.updateSettings({ streaming: { abr: { autoSwitchBitrate: { video: true } } } }); }
                            else { player.updateSettings({ streaming: { abr: { autoSwitchBitrate: { video: false } } } }); player.setQualityFor('video', lvl, true); }
                        });
                        autoplay(video);
                    });
                }

                video.addEventListener('play', () => setError(state, false));
                video.addEventListener('stalled', () => setError(state, true, 'Playback stalled'));

                document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && video.paused) { video.play().catch(() => { }); } });
            }

            function autoplay(video) { video.play().catch(() => { }); }

            function levelLabel(l) {
                const p = []; if (l.height) p.push(l.height + 'p'); if (l.bitrate) p.push(Math.round(l.bitrate / 1000) + ' kbps'); return p.join(' · ') || 'Level';
            }

            function buildLevelsMenu(state, levels, onPick) {
                const ul = state.qMenu.querySelector('ul');
                ul.innerHTML = '';
                const mk = (label, val, checked = false) => {
                    const li = document.createElement('li');
                    li.innerHTML = '<span>' + label + '</span>' + (checked ? '<span class="check">✓</span>' : '');
                    li.dataset.val = val;
                    li.addEventListener('click', (e) => { e.stopPropagation(); onPick(val); state.qMenu.classList.remove('open'); });
                    return li;
                };
                ul.appendChild(mk('Auto', -1));
                levels.forEach(l => { if (l.i !== -1) ul.appendChild(mk(l.label, l.i)); });
            }

            // CC menu: Auto-translate (detect) / Off / Embedded languages
            function buildCcMenu(state) {
                const v = state.video;
                const ul = state.ccMenu.querySelector('ul');
                ul.innerHTML = '';

                // Helper to close menu
                const close = () => state.ccMenu.classList.remove('open');

                // Auto-translate (Cloud CC) at top
                const autoItem = document.createElement('li');
                autoItem.innerHTML = '<span>Auto-translate (detect)</span>';
                autoItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // start Cloud CC (or stop if already on)
                    if (state.cloudCC) { stopCloudCC(state); } else { startCloudCC(state); }
                    // also turn off embedded tracks when enabling cloud CC
                    if (state.cloudCC) { setEmbeddedTrack(state, -1); }
                    close();
                });
                ul.appendChild(autoItem);

                // Separator
                const sep = document.createElement('div'); sep.className = 'sep';
                ul.appendChild(sep);

                // Off
                const off = document.createElement('li');
                off.innerHTML = '<span>Off</span>';
                off.addEventListener('click', (e) => {
                    e.stopPropagation();
                    stopCloudCC(state);
                    setEmbeddedTrack(state, -1);
                    close();
                });
                ul.appendChild(off);

                // Embedded captions section (languages)
                const tracks = Array.from(v.textTracks || []).filter(t => t.kind === 'subtitles' || t.kind === 'captions');
                if (tracks.length) {
                    const hint = document.createElement('div'); hint.className = 'hint'; hint.textContent = 'Embedded captions';
                    ul.appendChild(hint);

                    tracks.forEach((t, idx) => {
                        const li = document.createElement('li');
                        const label = (t.label || t.language || 'Track ' + (idx + 1));
                        const active = (t.mode === 'showing');
                        li.innerHTML = '<span>' + label + '</span>' + (active ? '<span class="check">✓</span>' : '');
                        li.addEventListener('click', (e) => {
                            e.stopPropagation();
                            stopCloudCC(state);
                            setEmbeddedTrack(state, idx);
                            close();
                        });
                        ul.appendChild(li);
                    });
                } else {
                    const none = document.createElement('div'); none.className = 'hint'; none.textContent = 'No embedded captions detected';
                    ul.appendChild(none);
                }
            }

            function setEmbeddedTrack(state, index) {
                const v = state.video;
                const tracks = v.textTracks || [];
                for (let i = 0; i < tracks.length; i++) {
                    const show = (i === index && index >= 0);
                    tracks[i].mode = show ? 'showing' : 'hidden';
                }
                state.ccOn = index >= 0;
            }

            function startCloudCC(state) {
                if (state.cloudCC) return;
                const v = state.video;
                if (!v.captureStream) { alert('Your browser does not support captureStream on video.'); return; }
                const ms = v.captureStream(); const audioTrack = ms.getAudioTracks()[0]; if (!audioTrack) { alert('No audio track available to transcribe.'); return; }
                const ctx = new (window.AudioContext || window.webkitAudioContext)(); const src = ctx.createMediaStreamSource(new MediaStream([audioTrack]));
                const proc = ctx.createScriptProcessor(4096, 1, 1);
                src.connect(proc); proc.connect(ctx.destination);

                if (!state.textTrack) { state.textTrack = state.video.addTextTrack('subtitles', 'Cloud CC', 'en'); }
                state.textTrack.mode = 'showing';

                const wsUrl = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/cloud-cc';
                const ws = new WebSocket(wsUrl); ws.binaryType = 'arraybuffer';

                const cc = {
                    stop() {
                        try { ws.close(); } catch (e) { }
                        try { proc.disconnect(); } catch (e) { }
                        try { src.disconnect(); } catch (e) { }
                        try { ctx.close(); } catch (e) { }
                    }
                };
                state.cloudCC = cc;

                ws.onmessage = (ev) => {
                    try {
                        const msg = JSON.parse(ev.data);
                        if (msg.type === 'cc' && msg.text) {
                            const now = state.video.currentTime;
                            const cue = new VTTCue(now, now + 4, msg.text);
                            state.textTrack.addCue(cue);
                        }
                    } catch (e) { }
                };

                proc.onaudioprocess = (e) => {
                    const buf = e.inputBuffer.getChannelData(0);
                    const rate = ctx.sampleRate / 16000; const outLen = Math.floor(buf.length / rate);
                    const out = new Int16Array(outLen);
                    for (let i = 0; i < outLen; i++) { const x = buf[Math.floor(i * rate)] || 0; out[i] = Math.max(-1, Math.min(1, x)) * 0x7fff; }
                    if (ws.readyState === 1) ws.send(out.buffer);
                };
            }

            function stopCloudCC(state) {
                if (!state.cloudCC) return;
                try { state.cloudCC.stop(); } catch (e) { }
                state.cloudCC = null;
            }

            function handleHlsError(state, data) {
                const fatal = data?.fatal; const details = data?.details; let msg = 'HLS error: ' + (details || 'Unknown');
                if (fatal) {
                    switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR: msg += ' (network)'; state.hls?.startLoad(); break;
                        case Hls.ErrorTypes.MEDIA_ERROR: msg += ' (media)'; state.hls?.recoverMediaError(); break;
                        default: setError(state, true, msg); break;
                    }
                } else {
                    setError(state, true, msg);
                }
            }

            function setError(state, show, message) {
                const el = state.root.querySelector('.error');
                if (show) {
                    if (message) state.root.querySelector('#' + state.root.dataset.id + '-errmsg')?.replaceChildren(document.createTextNode(message));
                    el.classList.add('show');
                    if (autoRetry.checked && !state.retry.on) { state.retry.on = true; scheduleRetry(state); }
                } else {
                    el.classList.remove('show');
                    if (!state.retry.on && state.retry.timer) { clearTimeout(state.retry.timer); state.retry.timer = null; state.retry.delay = 2000; }
                }
            }

            function scheduleRetry(state) {
                if (state.retry.timer) clearTimeout(state.retry.timer);
                state.retry.timer = setTimeout(() => {
                    reload(state.root.dataset.id);
                    state.retry.delay = Math.min(state.retry.delay * 1.6, 30000);
                    if (state.retry.on) scheduleRetry(state);
                }, state.retry.delay);
            }

            function reload(id) { const s = tiles.get(id); if (!s) return; setupPlayer(id, s); }

            function removeTile(id) {
                const s = tiles.get(id); if (!s) return;
                if (s.hls) s.hls.destroy();
                if (s.dash) s.dash.reset();
                s.root.remove(); tiles.delete(id); layout(); persist();
            }

            function toggleFullscreen(el) {
                if (document.fullscreenElement) { document.exitFullscreen().catch(() => { }); }
                else { el.requestFullscreen?.().catch(() => { }); }
            }

            // Persistence
            function persist() { saveStreams(Array.from(tiles.values()).map(s => s.url)); }
            function restore() { loadStreams().forEach(addStream); }

            // Add URL
            function addFromInput() { addStream(urlInput.value); urlInput.value = ''; urlInput.focus(); }
            urlInput.addEventListener('keydown', e => { if (e.key === 'Enter') { addFromInput(); } });
            addBtn.addEventListener('click', addFromInput);

            // Start
            restore();
        })();
    </script>
</body>

</html>