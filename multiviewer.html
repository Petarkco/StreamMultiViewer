<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Multi HLS Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- hls.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <style>
        /* Keep original feel: minimal styles; only add tiny helpers for new UI bits */

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            background: #111;
            color: #ddd;
        }

        header {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #2a2a2a;
            background: #1a1a1a;
        }

        header input[type="url"] {
            flex: 1;
            padding: 8px;
            background: #0d0d0d;
            color: #ddd;
            border: 1px solid #2a2a2a;
        }

        header button {
            padding: 8px 12px;
            background: #222;
            color: #ddd;
            border: 1px solid #2a2a2a;
            cursor: pointer;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 8px;
            padding: 8px;
            height: calc(100% - 50px);
            overflow: auto;
        }

        .tile {
            position: relative;
            background: #000;
            border: 1px solid #2a2a2a;
            min-height: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        video {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
            object-fit: contain;
        }

        /* Tiny control strip pinned at bottom; matches minimal aesthetic */
        .controls {
            position: absolute;
            left: 6px;
            right: 6px;
            bottom: 6px;
            display: flex;
            gap: 6px;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid #2a2a2a;
            padding: 4px 6px;
            font-size: 12px;
        }

        .controls .left,
        .controls .right {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 4px 8px;
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            color: #ddd;
            cursor: pointer;
            font-size: 12px;
        }

        .tag {
            color: #aaa;
            font-size: 11px;
            max-width: 40vw;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Error overlay (hidden by default) */
        .error-box {
            position: absolute;
            top: 6px;
            left: 6px;
            right: 6px;
            max-height: 40%;
            overflow: auto;
            display: none;
            background: rgba(32, 0, 0, 0.6);
            border: 1px solid #5a2a2a;
            color: #ffd0d0;
            padding: 6px;
            font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        }

        .error-box .row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 4px;
        }

        .error-box button {
            background: #2a0f12;
            color: #ffd0d0;
            border: 1px solid #5a2a2a;
            font-size: 11px;
            padding: 2px 6px;
            cursor: pointer;
        }

        .error-box pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Volume popover shown when hovering mute/unmute */
        .vol-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .vol-pop {
            position: absolute;
            bottom: 130%;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #2a2a2a;
            padding: 6px;
            white-space: nowrap;
        }

        .vol-wrap:hover .vol-pop {
            display: block;
        }

        .vol-pop input[type="range"] {
            width: 140px;
        }

        /* CC simple dropdown */
        .cc-wrap {
            position: relative;
        }

        .cc-menu {
            position: absolute;
            bottom: 130%;
            left: 0;
            display: none;
            min-width: 160px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #2a2a2a;
            padding: 4px;
            z-index: 5;
        }

        .cc-wrap.open .cc-menu {
            display: block;
        }

        .cc-item {
            padding: 4px 6px;
            cursor: pointer;
        }

        .cc-item:hover {
            background: #252525;
        }
    </style>
</head>

<body>
    <header>
        <button id="addBtn">Add</button>
        <button id="clearBtn">Clear All</button>
        <input id="urlInput" type="url" placeholder="Paste an HLS .m3u8 and press Add" />
    </header>

    <div id="grid" aria-live="polite"></div>

    <script>
        const grid = document.getElementById('grid');
        const urlInput = document.getElementById('urlInput');
        const addBtn = document.getElementById('addBtn');
        const clearBtn = document.getElementById('clearBtn');

        addBtn.addEventListener('click', () => {
            const url = (urlInput.value || '').trim();
            if (!url) return;
            addTile(url);
            urlInput.value = '';
            urlInput.focus();
        });
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') addBtn.click();
        });
        clearBtn.addEventListener('click', () => { grid.innerHTML = ''; });

        function addTile(url) {
            const tile = document.createElement('div');
            tile.className = 'tile';

            const video = document.createElement('video');
            video.playsInline = true;
            video.autoplay = true;
            video.controls = false;
            video.muted = true; // start muted for autoplay

            const controls = document.createElement('div');
            controls.className = 'controls';
            const left = document.createElement('div');
            left.className = 'left';
            const right = document.createElement('div');
            right.className = 'right';

            // Mute/Unmute + Volume on hover
            const volWrap = document.createElement('div');
            volWrap.className = 'vol-wrap';
            const muteBtn = document.createElement('button');
            muteBtn.className = 'btn';
            muteBtn.textContent = 'Mute';
            const volPop = document.createElement('div');
            volPop.className = 'vol-pop';
            volPop.innerHTML = '<input type="range" min="0" max="1" step="0.05" value="0.8">';
            const volSlider = volPop.querySelector('input');
            video.volume = parseFloat(volSlider.value);
            volSlider.addEventListener('input', () => {
                video.volume = parseFloat(volSlider.value);
                if (video.volume === 0 && !video.muted) {
                    video.muted = true;
                    muteBtn.textContent = 'Unmute';
                }
            });
            muteBtn.addEventListener('click', () => {
                video.muted = !video.muted;
                muteBtn.textContent = video.muted ? 'Unmute' : 'Mute';
            });
            volWrap.appendChild(muteBtn);
            volWrap.appendChild(volPop);
            left.appendChild(volWrap);

            // URL tag
            const tag = document.createElement('div');
            tag.className = 'tag';
            tag.textContent = url;
            left.appendChild(tag);

            // CC controls (default OFF)
            const ccWrap = document.createElement('div');
            ccWrap.className = 'cc-wrap';
            const ccBtn = document.createElement('button');
            ccBtn.className = 'btn';
            ccBtn.textContent = 'CC: Off';
            const ccMenu = document.createElement('div');
            ccMenu.className = 'cc-menu';
            ccWrap.appendChild(ccBtn);
            ccWrap.appendChild(ccMenu);
            ccBtn.addEventListener('click', () => ccWrap.classList.toggle('open'));
            document.addEventListener('click', (e) => {
                if (!ccWrap.contains(e.target)) ccWrap.classList.remove('open');
            });
            right.appendChild(ccWrap);

            // Remove tile
            const rm = document.createElement('button');
            rm.className = 'btn';
            rm.textContent = 'Remove';
            rm.addEventListener('click', () => {
                if (hls) { try { hls.destroy(); } catch (e) { } }
                tile.remove();
            });
            right.appendChild(rm);

            controls.appendChild(left);
            controls.appendChild(right);

            // Error box
            const err = document.createElement('div');
            err.className = 'error-box';
            err.innerHTML = '<div class="row"><strong>Stream Errors</strong><button type="button" data-close>Close</button></div><pre></pre>';
            const errPre = err.querySelector('pre');
            err.querySelector('[data-close]').addEventListener('click', () => { err.style.display = 'none'; });

            tile.appendChild(video);
            tile.appendChild(controls);
            tile.appendChild(err);
            grid.appendChild(tile);

            // HLS plumbing
            let hls = null;
            let usingNative = false;

            function logError(message) {
                const ts = new Date().toLocaleTimeString();
                errPre.textContent += '[' + ts + '] ' + message + '\n';
                err.style.display = 'block';
            }

            if (Hls.isSupported()) {
                hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 60,
                    renderTextTracksNatively: false
                });
                hls.attachMedia(video);
                hls.on(Hls.Events.MEDIA_ATTACHED, () => { hls.loadSource(url); });

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    // Captions default OFF
                    setupHlsCaptionsMenu(hls, ccMenu, ccBtn);
                    video.play().catch(() => { });
                });

                // Error reporting (non-fatal & fatal)
                hls.on(Hls.Events.ERROR, (_, data) => {
                    const { type, details, fatal } = data;
                    logError((fatal ? 'FATAL ' : '') + type + (details ? ' - ' + details : ''));
                    if (fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                try { hls.destroy(); } catch (e) { }
                                break;
                        }
                    }
                });

            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                usingNative = true;
                video.src = url;
                video.addEventListener('loadedmetadata', () => {
                    // Default all native text tracks OFF
                    const tracks = Array.from(video.textTracks || []);
                    tracks.forEach(t => t.mode = 'disabled');
                    setupNativeCaptionsMenu(video, ccMenu, ccBtn);
                });
                video.addEventListener('error', () => {
                    const me = video.error;
                    logError('MEDIA ' + (me ? (me.message || me.code) : 'unknown') + ' (native)');
                });
                video.play().catch(() => { });
            } else {
                logError('HLS not supported on this browser.');
            }
        }

        function setupHlsCaptionsMenu(hls, menu, btn) {
            // Build menu with Off + available subtitleTracks (if any)
            const tracks = Array.isArray(hls.subtitleTracks) ? hls.subtitleTracks : [];
            hls.subtitleDisplay = false;
            hls.subtitleTrack = -1;

            menu.innerHTML = '';
            const off = document.createElement('div');
            off.className = 'cc-item';
            off.textContent = 'Off';
            off.addEventListener('click', () => {
                hls.subtitleDisplay = false;
                hls.subtitleTrack = -1;
                btn.textContent = 'CC: Off';
                menu.parentElement.classList.remove('open');
            });
            menu.appendChild(off);

            tracks.forEach((t, i) => {
                const lab = t.name || t.lang || 'Subtitles';
                const it = document.createElement('div');
                it.className = 'cc-item';
                it.textContent = lab;
                it.addEventListener('click', () => {
                    hls.subtitleDisplay = true;
                    hls.subtitleTrack = i;
                    btn.textContent = 'CC: ' + lab;
                    menu.parentElement.classList.remove('open');
                });
                menu.appendChild(it);
            });

            // In case tracks appear later
            hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, () => {
                setupHlsCaptionsMenu(hls, menu, btn);
            });
        }

        function setupNativeCaptionsMenu(video, menu, btn) {
            const textTracks = Array.from(video.textTracks || [])
                .filter(t => t.kind === 'subtitles' || t.kind === 'captions');

            textTracks.forEach(t => t.mode = 'disabled');
            menu.innerHTML = '';

            const off = document.createElement('div');
            off.className = 'cc-item';
            off.textContent = 'Off';
            off.addEventListener('click', () => {
                textTracks.forEach(t => t.mode = 'disabled');
                btn.textContent = 'CC: Off';
                menu.parentElement.classList.remove('open');
            });
            menu.appendChild(off);

            textTracks.forEach((t, i) => {
                const lab = t.label || t.language || 'Subtitles';
                const it = document.createElement('div');
                it.className = 'cc-item';
                it.textContent = lab;
                it.addEventListener('click', () => {
                    textTracks.forEach((tt, j) => { tt.mode = (i === j) ? 'showing' : 'disabled'; });
                    btn.textContent = 'CC: ' + lab;
                    menu.parentElement.classList.remove('open');
                });
                menu.appendChild(it);
            });

            // If tracks added later
            video.textTracks && (video.textTracks.onaddtrack = () => {
                setupNativeCaptionsMenu(video, menu, btn);
            });
        }

        // Optional: allow quick test via hash
        // multiviewer.html#https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8
        window.addEventListener('DOMContentLoaded', () => {
            const h = decodeURIComponent(location.hash.replace(/^#/, '')).trim();
            if (h && /^https?:\/\/.+/.test(h)) addTile(h);
        });
    </script>
</body>

</html>