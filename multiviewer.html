<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Multi HLS Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- hls.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <!-- Online icon source: Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            background: #111;
            color: #ddd;
        }

        header {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #2a2a2a;
            background: #1a1a1a;
        }

        header button {
            padding: 8px 12px;
            background: #222;
            color: #ddd;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        header input[type="url"] {
            flex: 1;
            padding: 8px;
            background: #0d0d0d;
            color: #ddd;
            border: 1px solid #2a2a2a;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 8px;
            padding: 8px;
            height: calc(100% - 50px);
            overflow: auto;
        }

        .tile {
            position: relative;
            background: #000;
            border: 1px solid #2a2a2a;
            min-height: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        video {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
            object-fit: contain;
        }

        /* Control strip appears on hover */
        .controls {
            position: absolute;
            left: 6px;
            right: 6px;
            bottom: 6px;
            display: flex;
            gap: 6px;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid #2a2a2a;
            padding: 4px 6px;
            font-size: 12px;
            opacity: 0;
            transition: opacity .15s ease-in-out;
            pointer-events: none;
            /* prevent focus when hidden */
        }

        .tile:hover .controls,
        .controls:focus-within {
            opacity: 1;
            pointer-events: auto;
        }

        .controls .left,
        .controls .right {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 4px 8px;
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            color: #ddd;
            cursor: pointer;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn.icon {
            padding: 4px 8px;
            width: auto;
        }

        .tag {
            color: #aaa;
            font-size: 11px;
            max-width: 40vw;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Error overlay (hidden by default) */
        .error-box {
            position: absolute;
            top: 6px;
            left: 6px;
            right: 6px;
            max-height: 40%;
            overflow: auto;
            display: none;
            background: rgba(32, 0, 0, 0.6);
            border: 1px solid #5a2a2a;
            color: #ffd0d0;
            padding: 6px;
            font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            z-index: 5;
        }

        .error-box .row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 4px;
            align-items: center;
        }

        .error-box .row strong {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .error-box button {
            background: #2a0f12;
            color: #ffd0d0;
            border: 1px solid #5a2a2a;
            font-size: 11px;
            padding: 2px 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .error-box pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Volume popover: keep open while hovering slider; JS will clamp position */
        .vol-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .vol-pop {
            position: absolute;
            top: auto;
            bottom: 130%;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #2a2a2a;
            padding: 6px;
            white-space: nowrap;
            z-index: 6;
        }

        .vol-wrap:hover .vol-pop,
        .vol-pop:hover {
            display: block;
        }

        .vol-pop input[type="range"] {
            width: 160px;
        }

        /* CC simple dropdown */
        .cc-wrap {
            position: relative;
        }

        .cc-menu {
            position: absolute;
            bottom: 130%;
            left: 0;
            display: none;
            min-width: 160px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #2a2a2a;
            padding: 4px;
            z-index: 6;
        }

        .cc-wrap.open .cc-menu {
            display: block;
        }

        .cc-item {
            padding: 4px 6px;
            cursor: pointer;
        }

        .cc-item:hover {
            background: #252525;
        }
    </style>
</head>

<body>
    <header>
        <button id="addBtn" title="Add stream"><i class="bi bi-plus-lg"></i> Add</button>
        <button id="clearBtn" title="Remove all streams"><i class="bi bi-trash"></i> Clear All</button>
        <input id="urlInput" type="url" placeholder="Paste an HLS .m3u8 and press Add" />
    </header>

    <div id="grid" aria-live="polite"></div>

    <script>
        const grid = document.getElementById('grid');
        const urlInput = document.getElementById('urlInput');
        const addBtn = document.getElementById('addBtn');
        const clearBtn = document.getElementById('clearBtn');

        addBtn.addEventListener('click', () => {
            const url = (urlInput.value || '').trim();
            if (!url) return;
            addTile(url);
            urlInput.value = '';
            urlInput.focus();
        });
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') addBtn.click();
        });
        clearBtn.addEventListener('click', () => { grid.innerHTML = ''; });

        function addTile(url) {
            const tile = document.createElement('div');
            tile.className = 'tile';

            const video = document.createElement('video');
            video.playsInline = true;
            video.autoplay = true;
            video.controls = false;
            video.muted = true; // start muted for autoplay

            const controls = document.createElement('div');
            controls.className = 'controls';
            const left = document.createElement('div');
            left.className = 'left';
            const right = document.createElement('div');
            right.className = 'right';

            // Mute/Unmute + Volume (icons)
            const volWrap = document.createElement('div');
            volWrap.className = 'vol-wrap';

            const muteBtn = document.createElement('button');
            muteBtn.className = 'btn icon';
            muteBtn.innerHTML = '<i class="bi bi-volume-up"></i>';
            muteBtn.title = 'Mute/Unmute';

            const volPop = document.createElement('div');
            volPop.className = 'vol-pop';
            volPop.innerHTML = '<input type="range" min="0" max="1" step="0.05" value="0.8" aria-label="Volume">';
            const volSlider = volPop.querySelector('input');

            video.volume = parseFloat(volSlider.value);
            volSlider.addEventListener('input', () => {
                video.volume = parseFloat(volSlider.value);
                if (video.volume === 0 && !video.muted) {
                    video.muted = true;
                    muteBtn.innerHTML = '<i class="bi bi-volume-mute"></i>';
                } else if (video.volume > 0 && video.muted) {
                    // keep muted until explicitly unmuted
                }
            });

            muteBtn.addEventListener('click', () => {
                video.muted = !video.muted;
                muteBtn.innerHTML = video.muted
                    ? '<i class="bi bi-volume-mute"></i>'
                    : '<i class="bi bi-volume-up"></i>';
            });

            // Clamp the popover so it doesn't go off-screen
            function positionVolumePop() {
                const pop = volPop;
                pop.style.left = '50%';
                pop.style.transform = 'translateX(-50%)';
                pop.style.right = 'auto';
                // After shown, clamp if needed
                requestAnimationFrame(() => {
                    const pr = pop.getBoundingClientRect();
                    const gr = grid.getBoundingClientRect();
                    let dx = 0;
                    if (pr.left < gr.left + 4) dx = (gr.left + 4) - pr.left;
                    else if (pr.right > gr.right - 4) dx = (gr.right - 4) - pr.right;
                    pop.style.transform = `translateX(calc(-50% + ${dx}px))`;
                });
            }
            volWrap.addEventListener('mouseenter', positionVolumePop);

            volWrap.appendChild(muteBtn);
            volWrap.appendChild(volPop);
            left.appendChild(volWrap);

            // URL tag
            const tag = document.createElement('div');
            tag.className = 'tag';
            tag.textContent = url;
            left.appendChild(tag);

            // CC controls (default OFF) with icon
            const ccWrap = document.createElement('div');
            ccWrap.className = 'cc-wrap';

            const ccBtn = document.createElement('button');
            ccBtn.className = 'btn';
            ccBtn.innerHTML = '<i class="bi bi-badge-cc"></i> Off';
            ccBtn.title = 'Closed captions';

            const ccMenu = document.createElement('div');
            ccMenu.className = 'cc-menu';
            ccWrap.appendChild(ccBtn);
            ccWrap.appendChild(ccMenu);

            ccBtn.addEventListener('click', () => ccWrap.classList.toggle('open'));
            document.addEventListener('click', (e) => {
                if (!ccWrap.contains(e.target)) ccWrap.classList.remove('open');
            });
            right.appendChild(ccWrap);

            // Remove tile (trash icon)
            const rm = document.createElement('button');
            rm.className = 'btn';
            rm.innerHTML = '<i class="bi bi-trash"></i> Remove';
            rm.addEventListener('click', () => {
                if (hls) { try { hls.destroy(); } catch (e) { } }
                tile.remove();
            });
            right.appendChild(rm);

            controls.appendChild(left);
            controls.appendChild(right);

            // Error box with warning icon
            const err = document.createElement('div');
            err.className = 'error-box';
            err.innerHTML = '<div class="row"><strong><i class="bi bi-exclamation-triangle"></i> Stream Errors</strong><button type="button" data-close><i class="bi bi-x-lg"></i> Close</button></div><pre></pre>';
            const errPre = err.querySelector('pre');
            err.querySelector('[data-close]').addEventListener('click', () => { err.style.display = 'none'; });

            tile.appendChild(video);
            tile.appendChild(controls);
            tile.appendChild(err);
            grid.appendChild(tile);

            // HLS plumbing
            let hls = null;
            let usingNative = false;

            function logError(message) {
                const ts = new Date().toLocaleTimeString();
                errPre.textContent += '[' + ts + '] ' + message + '\n';
                err.style.display = 'block';
            }

            // Build/refresh CC menu from both hls subtitleTracks and native textTracks
            function refreshCaptionMenu() {
                const items = []; // {label, type:'hls'|'native', index}
                // hls subtitle tracks
                if (hls && Array.isArray(hls.subtitleTracks) && hls.subtitleTracks.length > 0) {
                    hls.subtitleTracks.forEach((t, i) => {
                        items.push({ label: t.name || t.lang || 'Subtitles', type: 'hls', index: i });
                    });
                }
                // native text tracks (covers Safari and CEA-608/708 exposed by hls.js when renderTextTracksNatively=false)
                const nativeTracks = Array.from(video.textTracks || []).filter(t =>
                    t.kind === 'subtitles' || t.kind === 'captions'
                );
                nativeTracks.forEach((t, i) => {
                    const label = t.label || t.language || 'Subtitles';
                    // avoid duplicate labels if already present from hls list
                    if (!items.some(x => x.label === label)) {
                        items.push({ label, type: 'native', index: i });
                    }
                });

                ccMenu.innerHTML = '';
                const off = document.createElement('div');
                off.className = 'cc-item';
                off.textContent = 'Off';
                off.addEventListener('click', () => {
                    // turn off both
                    if (hls) {
                        hls.subtitleDisplay = false;
                        hls.subtitleTrack = -1;
                    }
                    nativeTracks.forEach(t => t.mode = 'disabled');
                    ccBtn.innerHTML = '<i class="bi bi-badge-cc"></i> Off';
                    ccWrap.classList.remove('open');
                });
                ccMenu.appendChild(off);

                items.forEach((it) => {
                    const node = document.createElement('div');
                    node.className = 'cc-item';
                    node.textContent = it.label;
                    node.addEventListener('click', () => {
                        // off everything first
                        if (hls) {
                            hls.subtitleDisplay = false;
                            hls.subtitleTrack = -1;
                        }
                        nativeTracks.forEach(t => t.mode = 'disabled');
                        // then enable chosen
                        if (it.type === 'hls' && hls) {
                            hls.subtitleDisplay = true;
                            hls.subtitleTrack = it.index;
                        } else if (it.type === 'native') {
                            nativeTracks.forEach((t, j) => { t.mode = (j === it.index) ? 'showing' : 'disabled'; });
                        }
                        ccBtn.innerHTML = '<i class="bi bi-badge-cc"></i> ' + it.label;
                        ccWrap.classList.remove('open');
                    });
                    ccMenu.appendChild(node);
                });
            }

            if (Hls.isSupported()) {
                hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 60,
                    renderTextTracksNatively: false // expose 608/708 as textTracks on the video
                });
                hls.attachMedia(video);
                hls.on(Hls.Events.MEDIA_ATTACHED, () => { hls.loadSource(url); });

                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    // default CC off
                    hls.subtitleDisplay = false;
                    hls.subtitleTrack = -1;
                    refreshCaptionMenu();
                    video.play().catch(() => { });
                });

                // If subtitle tracks update later (common), refresh menu
                hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, refreshCaptionMenu);
                hls.on(Hls.Events.LEVEL_LOADED, refreshCaptionMenu);
                hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, refreshCaptionMenu);

                // Error reporting (non-fatal & fatal)
                hls.on(Hls.Events.ERROR, (_, data) => {
                    const { type, details, fatal } = data;
                    logError((fatal ? 'FATAL ' : '') + type + (details ? ' - ' + details : ''));
                    if (fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                try { hls.destroy(); } catch (e) { }
                                break;
                        }
                    }
                    // some errors add or change textTracks late
                    refreshCaptionMenu();
                });

                // When hls exposes CEA-608/708 as native text tracks, they may appear after playback starts
                video.addEventListener('loadedmetadata', refreshCaptionMenu);
                video.addEventListener('durationchange', refreshCaptionMenu);
                video.addEventListener('timeupdate', () => {
                    // light polling the first few seconds to catch late-appearing tracks
                    if (!video._polledCC) {
                        video._polledCC = 1;
                        let n = 0;
                        const id = setInterval(() => {
                            refreshCaptionMenu();
                            if (++n > 8) clearInterval(id);
                        }, 500);
                    }
                });

            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                usingNative = true;
                video.src = url;

                const nativeRefreshHooks = () => {
                    // Default all native text tracks OFF
                    const tracks = Array.from(video.textTracks || []);
                    tracks.forEach(t => t.mode = 'disabled');
                    refreshCaptionMenu();
                };

                video.addEventListener('loadedmetadata', nativeRefreshHooks);
                video.addEventListener('error', () => {
                    const me = video.error;
                    logError('MEDIA ' + (me ? (me.message || me.code) : 'unknown') + ' (native)');
                });
                // Safari sometimes adds tracks after playback starts
                video.addEventListener('play', () => setTimeout(refreshCaptionMenu, 300));
                if (video.textTracks) {
                    video.textTracks.onaddtrack = refreshCaptionMenu;
                    video.textTracks.onchange = refreshCaptionMenu;
                }
                video.play().catch(() => { });
            } else {
                logError('HLS not supported on this browser.');
            }
        }

        // Optional: quick test via hash
        // multiviewer.html#https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8
        window.addEventListener('DOMContentLoaded', () => {
            const h = decodeURIComponent(location.hash.replace(/^#/, '')).trim();
            if (h && /^https?:\/\/.+/.test(h)) addTile(h);
        });
    </script>
</body>

</html>