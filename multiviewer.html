<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Multi HLS Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- hls.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

    <!-- Online icon source: Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            background: #111;
            color: #ddd;
        }

        header {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #2a2a2a;
            background: #1a1a1a;
        }

        header button {
            padding: 8px 12px;
            background: #222;
            color: #ddd;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        header input[type="url"] {
            flex: 1;
            padding: 8px;
            background: #0d0d0d;
            color: #ddd;
            border: 1px solid #2a2a2a;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 8px;
            padding: 8px;
            height: calc(100% - 50px);
            overflow: auto;
        }

        .tile {
            position: relative;
            background: #000;
            border: 1px solid #2a2a2a;
            min-height: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        video {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
            object-fit: contain;
        }

        /* Control strip appears on hover; JS can pin it with .sticky while slider is open */
        .controls {
            position: absolute;
            left: 6px;
            right: 6px;
            bottom: 6px;
            display: flex;
            gap: 6px;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid #2a2a2a;
            padding: 4px 6px;
            font-size: 12px;
            opacity: 0;
            transition: opacity .15s ease-in-out;
            pointer-events: none;
        }

        .tile:hover .controls,
        .controls:focus-within,
        .controls.sticky {
            opacity: 1;
            pointer-events: auto;
        }

        .controls .left,
        .controls .right {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 4px 8px;
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            color: #ddd;
            cursor: pointer;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn.icon {
            padding: 4px 8px;
        }

        .tag {
            color: #aaa;
            font-size: 11px;
            max-width: 40vw;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Error overlay */
        .error-box {
            position: absolute;
            top: 6px;
            left: 6px;
            right: 6px;
            max-height: 40%;
            overflow: auto;
            display: none;
            background: rgba(32, 0, 0, 0.6);
            border: 1px solid #5a2a2a;
            color: #ffd0d0;
            padding: 6px;
            font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            z-index: 5;
        }

        .error-box .row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 4px;
            align-items: center;
        }

        .error-box .row strong {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .error-box button {
            background: #2a0f12;
            color: #ffd0d0;
            border: 1px solid #5a2a2a;
            font-size: 11px;
            padding: 2px 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .error-box pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Volume popover driven by JS (no :hover gaps) */
        .vol-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .vol-pop {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #2a2a2a;
            padding: 6px;
            white-space: nowrap;
            z-index: 6;
            bottom: 130%;
            left: 50%;
            transform: translateX(-50%);
        }

        .vol-pop.open {
            display: block;
        }

        .vol-pop.below {
            top: 130%;
            bottom: auto;
        }

        .vol-pop input[type="range"] {
            width: 180px;
        }

        /* CC simple dropdown */
        .cc-wrap {
            position: relative;
        }

        .cc-menu {
            position: absolute;
            bottom: 130%;
            left: 0;
            display: none;
            min-width: 160px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #2a2a2a;
            padding: 4px;
            z-index: 6;
        }

        .cc-wrap.open .cc-menu {
            display: block;
        }

        .cc-item {
            padding: 4px 6px;
            cursor: pointer;
        }

        .cc-item:hover {
            background: #252525;
        }
    </style>
</head>

<body>
    <header>
        <button id="addBtn" title="Add stream"><i class="bi bi-plus-lg"></i> Add</button>
        <button id="clearBtn" title="Remove all streams"><i class="bi bi-trash"></i> Clear All</button>
        <input id="urlInput" type="url" placeholder="Paste an HLS .m3u8 and press Add" />
    </header>

    <div id="grid" aria-live="polite"></div>

    <script>
        const grid = document.getElementById('grid');
        const urlInput = document.getElementById('urlInput');
        const addBtn = document.getElementById('addBtn');
        const clearBtn = document.getElementById('clearBtn');

        addBtn.addEventListener('click', () => {
            const url = (urlInput.value || '').trim();
            if (!url) return;
            addTile(url);
            urlInput.value = '';
            urlInput.focus();
        });
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') addBtn.click();
        });
        clearBtn.addEventListener('click', () => { grid.innerHTML = ''; });

        function addTile(url) {
            const tile = document.createElement('div');
            tile.className = 'tile';

            const video = document.createElement('video');
            video.playsInline = true;
            video.autoplay = true;
            video.controls = false;
            video.muted = true;

            const controls = document.createElement('div');
            controls.className = 'controls';
            const left = document.createElement('div');
            left.className = 'left';
            const right = document.createElement('div');
            right.className = 'right';

            // Mute/Unmute + Volume (icons)
            const volWrap = document.createElement('div');
            volWrap.className = 'vol-wrap';

            const muteBtn = document.createElement('button');
            muteBtn.className = 'btn icon';
            muteBtn.innerHTML = '<i class="bi bi-volume-up"></i>';
            muteBtn.title = 'Mute/Unmute';

            const volPop = document.createElement('div');
            volPop.className = 'vol-pop';
            volPop.innerHTML = '<input type="range" min="0" max="1" step="0.05" value="0.8" aria-label="Volume">';
            const volSlider = volPop.querySelector('input');

            video.volume = parseFloat(volSlider.value);

            // Show/hide logic with grace period; pin controls while open
            let hideTimer = null;
            function openVol() {
                clearTimeout(hideTimer);
                volPop.classList.add('open');
                controls.classList.add('sticky');
                positionVolumePop();
            }
            function scheduleCloseVol() {
                clearTimeout(hideTimer);
                hideTimer = setTimeout(() => {
                    volPop.classList.remove('open');
                    controls.classList.remove('sticky');
                }, 200);
            }

            volWrap.addEventListener('mouseenter', openVol);
            volWrap.addEventListener('mouseleave', (e) => {
                // if leaving to the pop itself, keep open
                if (!volPop.contains(e.relatedTarget)) scheduleCloseVol();
            });
            volPop.addEventListener('mouseenter', openVol);
            volPop.addEventListener('mouseleave', scheduleCloseVol);

            volSlider.addEventListener('input', () => {
                video.volume = parseFloat(volSlider.value);
                if (video.volume === 0 && !video.muted) {
                    video.muted = true;
                    muteBtn.innerHTML = '<i class="bi bi-volume-mute"></i>';
                }
            });

            muteBtn.addEventListener('click', () => {
                video.muted = !video.muted;
                muteBtn.innerHTML = video.muted
                    ? '<i class="bi bi-volume-mute"></i>'
                    : '<i class="bi bi-volume-up"></i>';
            });

            // Positioning: clamp horizontally to viewport, flip below if not enough space above
            function positionVolumePop() {
                // reset to default above/center
                volPop.classList.remove('below');
                volPop.style.left = '50%';
                volPop.style.transform = 'translateX(-50%)';

                // after visible, compute
                requestAnimationFrame(() => {
                    const margin = 8;
                    const pr = volPop.getBoundingClientRect();
                    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);

                    // Flip below if cut off at the top
                    if (pr.top < margin) {
                        volPop.classList.add('below');
                    }

                    // Recompute after flip
                    const pr2 = volPop.getBoundingClientRect();

                    // Clamp horizontally to viewport
                    let dx = 0;
                    if (pr2.left < margin) dx = margin - pr2.left;
                    else if (pr2.right > vw - margin) dx = (vw - margin) - pr2.right;

                    // Apply delta to the center translate
                    volPop.style.transform = `translateX(calc(-50% + ${dx}px))`;
                });
            }
            window.addEventListener('resize', () => { if (volPop.classList.contains('open')) positionVolumePop(); });
            window.addEventListener('scroll', () => { if (volPop.classList.contains('open')) positionVolumePop(); }, true);

            volWrap.appendChild(muteBtn);
            volWrap.appendChild(volPop);
            left.appendChild(volWrap);

            // URL tag
            const tag = document.createElement('div');
            tag.className = 'tag';
            tag.textContent = url;
            left.appendChild(tag);

            // CC controls (default OFF) with icon
            const ccWrap = document.createElement('div');
            ccWrap.className = 'cc-wrap';

            const ccBtn = document.createElement('button');
            ccBtn.className = 'btn';
            ccBtn.innerHTML = '<i class="bi bi-badge-cc"></i> Off';
            ccBtn.title = 'Closed captions';

            const ccMenu = document.createElement('div');
            ccMenu.className = 'cc-menu';
            ccWrap.appendChild(ccBtn);
            ccWrap.appendChild(ccMenu);

            ccBtn.addEventListener('click', () => ccWrap.classList.toggle('open'));
            document.addEventListener('click', (e) => {
                if (!ccWrap.contains(e.target)) ccWrap.classList.remove('open');
            });
            right.appendChild(ccWrap);

            // Remove tile
            const rm = document.createElement('button');
            rm.className = 'btn';
            rm.innerHTML = '<i class="bi bi-trash"></i> Remove';
            rm.addEventListener('click', () => {
                if (hls) { try { hls.destroy(); } catch (e) { } }
                tile.remove();
            });
            right.appendChild(rm);

            controls.appendChild(left);
            controls.appendChild(right);

            // Error box
            const err = document.createElement('div');
            err.className = 'error-box';
            err.innerHTML = '<div class="row"><strong><i class="bi bi-exclamation-triangle"></i> Stream Errors</strong><button type="button" data-close><i class="bi bi-x-lg"></i> Close</button></div><pre></pre>';
            const errPre = err.querySelector('pre');
            err.querySelector('[data-close]').addEventListener('click', () => { err.style.display = 'none'; });

            tile.appendChild(video);
            tile.appendChild(controls);
            tile.appendChild(err);
            grid.appendChild(tile);

            // HLS plumbing
            let hls = null;

            function logError(message) {
                const ts = new Date().toLocaleTimeString();
                errPre.textContent += '[' + ts + '] ' + message + '\n';
                err.style.display = 'block';
            }

            function refreshCaptionMenu() {
                const items = [];
                if (hls && Array.isArray(hls.subtitleTracks) && hls.subtitleTracks.length > 0) {
                    hls.subtitleTracks.forEach((t, i) => {
                        items.push({ label: t.name || t.lang || 'Subtitles', type: 'hls', index: i });
                    });
                }
                const nativeTracks = Array.from(video.textTracks || []).filter(t =>
                    t.kind === 'subtitles' || t.kind === 'captions'
                );
                nativeTracks.forEach((t, i) => {
                    const label = t.label || t.language || 'Subtitles';
                    if (!items.some(x => x.label === label)) items.push({ label, type: 'native', index: i });
                });

                ccMenu.innerHTML = '';
                const off = document.createElement('div');
                off.className = 'cc-item';
                off.textContent = 'Off';
                off.addEventListener('click', () => {
                    if (hls) {
                        hls.subtitleDisplay = false;
                        hls.subtitleTrack = -1;
                    }
                    nativeTracks.forEach(t => t.mode = 'disabled');
                    ccBtn.innerHTML = '<i class="bi bi-badge-cc"></i> Off';
                    ccWrap.classList.remove('open');
                });
                ccMenu.appendChild(off);

                items.forEach((it) => {
                    const node = document.createElement('div');
                    node.className = 'cc-item';
                    node.textContent = it.label;
                    node.addEventListener('click', () => {
                        if (hls) {
                            hls.subtitleDisplay = false;
                            hls.subtitleTrack = -1;
                        }
                        nativeTracks.forEach(t => t.mode = 'disabled');
                        if (it.type === 'hls' && hls) {
                            hls.subtitleDisplay = true;
                            hls.subtitleTrack = it.index;
                        } else if (it.type === 'native') {
                            nativeTracks.forEach((t, j) => { t.mode = (j === it.index) ? 'showing' : 'disabled'; });
                        }
                        ccBtn.innerHTML = '<i class="bi bi-badge-cc"></i> ' + it.label;
                        ccWrap.classList.remove('open');
                    });
                    ccMenu.appendChild(node);
                });
            }

            if (Hls.isSupported()) {
                hls = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 60,
                    renderTextTracksNatively: false
                });
                hls.attachMedia(video);
                hls.on(Hls.Events.MEDIA_ATTACHED, () => { hls.loadSource(url); });
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    hls.subtitleDisplay = false;
                    hls.subtitleTrack = -1;
                    refreshCaptionMenu();
                    video.play().catch(() => { });
                });
                hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, refreshCaptionMenu);
                hls.on(Hls.Events.LEVEL_LOADED, refreshCaptionMenu);
                hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, refreshCaptionMenu);
                hls.on(Hls.Events.ERROR, (_, data) => {
                    const { type, details, fatal } = data;
                    logError((fatal ? 'FATAL ' : '') + type + (details ? ' - ' + details : ''));
                    if (fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                try { hls.destroy(); } catch (e) { }
                                break;
                        }
                    }
                    refreshCaptionMenu();
                });
                video.addEventListener('loadedmetadata', refreshCaptionMenu);
                video.addEventListener('play', () => {
                    let n = 0;
                    const id = setInterval(() => {
                        refreshCaptionMenu();
                        if (++n > 8) clearInterval(id);
                    }, 500);
                });
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = url;
                const hook = () => {
                    const tracks = Array.from(video.textTracks || []);
                    tracks.forEach(t => t.mode = 'disabled');
                    refreshCaptionMenu();
                };
                video.addEventListener('loadedmetadata', hook);
                video.addEventListener('play', () => setTimeout(refreshCaptionMenu, 300));
                if (video.textTracks) {
                    video.textTracks.onaddtrack = refreshCaptionMenu;
                    video.textTracks.onchange = refreshCaptionMenu;
                }
                video.addEventListener('error', () => {
                    const me = video.error;
                    logError('MEDIA ' + (me ? (me.message || me.code) : 'unknown') + ' (native)');
                });
                video.play().catch(() => { });
            } else {
                logError('HLS not supported on this browser.');
            }

            // mount
            tile.appendChild(video);
            tile.appendChild(controls);
            tile.appendChild(err);
            grid.appendChild(tile);
        }

        // Optional: quick test via hash
        window.addEventListener('DOMContentLoaded', () => {
            const h = decodeURIComponent(location.hash.replace(/^#/, '')).trim();
            if (h && /^https?:\/\/.+/.test(h)) addTile(h);
        });
    </script>
</body>

</html>